"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const requestUtil_js_1 = require("./requestUtil.js");
const async_exit_hook_1 = __importDefault(require("async-exit-hook"));
const fastify_1 = __importDefault(require("fastify"));
const node_fs_1 = require("node:fs");
const promises_1 = require("node:fs/promises");
const node_os_1 = require("node:os");
const node_path_1 = require("node:path");
const server = (0, fastify_1.default)();
const dataPath = process.env.DATA_PATH || (0, node_path_1.join)((0, node_os_1.homedir)(), 'bare-data.json');
function getData() {
    try {
        return JSON.parse((0, node_fs_1.readFileSync)(dataPath, 'utf-8'));
    }
    catch (err) {
        if (err?.code !== 'ENOENT')
            throw err;
        console.log('Creating new', dataPath);
        return {
            req: {
                req: { names: {}, values: {} },
                res: { names: {}, values: {} },
            },
            ws: {
                req: { names: {}, values: {} },
                res: { names: {}, values: {} },
            },
        };
    }
}
const data = getData();
const abort = new AbortController();
function sleep(ms, signal) {
    return new Promise((resolve, reject) => {
        const cleanup = () => {
            clearTimeout(timeout);
            signal.removeEventListener('abort', onAbort);
        };
        const onAbort = () => {
            cleanup();
            reject();
        };
        const timeout = setTimeout(() => {
            cleanup();
            resolve();
        }, ms);
        signal.addEventListener('abort', onAbort);
    });
}
let globalSave = Promise.resolve();
function doSave() {
    console.log(Date.now(), 'Saving.');
    globalSave = globalSave.then(() => {
        globalSave = (0, promises_1.writeFile)(dataPath, JSON.stringify(data)).then(() => {
            console.log('Saved');
        });
        return globalSave;
    });
    return globalSave;
}
(0, async_exit_hook_1.default)((done) => {
    abort.abort();
    doSave().then(() => done());
});
(async () => {
    try {
        while (true) {
            await sleep(60e3 - 5e3, abort.signal);
            console.log(Date.now(), 'Saving in 5 seconds...');
            await sleep(5e3, abort.signal);
            await doSave();
        }
    }
    catch (err) {
        console.error('Interval broke');
    }
})();
server.post('/upload', async (req, reply) => {
    const body = req.body;
    const store = data[body.type][body.when];
    const lowerHeaders = Object.fromEntries(Object.entries(body.headers).map(([a, b]) => [a.toLowerCase(), b]));
    for (const header in lowerHeaders) {
        if (!(header in store.names))
            store.names[header] = 0;
        store.names[header]++;
        if (!(header in store.values))
            store.values[header] = 0;
        let value = body.headers[header];
        if (value) {
            // FOR V3, WE ONLY NEED A VALUE OF 1
            if (!Array.isArray(value))
                value = [value];
            for (const v of value) {
                if (v.length > store.values[header])
                    store.values[header]++;
            }
        }
    }
    reply.send();
});
server.listen({
    port: requestUtil_js_1.trackerPort,
});
//# sourceMappingURL=server2.js.map